# UI Rendering in FKNB

FkNB provides a clean and interactive user interface within Neovim for notebook cells. This document explains how the UI elements are rendered and updated.

## 1. `lua/fknb/ui/cell_ui.lua` - The Cell UI Manager

`cell_ui.lua` is the primary module responsible for managing the visual representation of individual notebook cells. Its key functions include:

*   **`M.attach_autocmd()`:** This function sets up Neovim autocommands that trigger UI updates. Specifically, it listens for `BufEnter`, `TextChanged`, and `TextChangedI` events on `.fknb` files. It also starts a timer that periodically triggers UI updates for animations (like the spinner).
*   **`draw(buf)`:** This is the core rendering function. Instead of redrawing the entire buffer every time, it implements a diffing mechanism:
    *   It parses the current buffer to get the latest cell structure (`require("fknb.core.parser").parse(buf)`).
    *   It compares the current `state.cells` with `state.prev_cells` to identify cells that have been added, removed, or modified.
    *   For removed cells, it clears their associated virtual text.
    *   For new or updated cells, it calls `require("fknb.core.renderer").render_cell(buf, cell)` to draw or update their UI.
*   **`get_status(cell)`:** Retrieves the current status of a cell (e.g., "ready", "running", "error") from the `cell` object in `state.cells`.
*   **Virtual Text Generation:** Within the `draw` function, it constructs the virtual text for the cell header, including the status icon (spinner for running cells), cell ID, language icon, and action icons.

## 2. `lua/fknb/core/renderer.lua` - The Low-Level Renderer

`renderer.lua` handles the actual placement of virtual text and lines in the Neovim buffer using extmarks. Its main function is:

*   **`M.render_cell(bufnr, cell)`:** This function is called by `cell_ui.lua` to render a specific cell's UI and output.
    *   It clears any existing virtual text for the given cell's range to prevent duplicates.
    *   It uses `vim.api.nvim_buf_set_extmark()` to place virtual lines above the cell's content (`virt_lines_above = true`) for the cell header.
    *   If the `cell` object contains `output` data, it calls `output_ui.create_output_text()` to format the output and then places it as virtual lines below the cell's content.

## 3. `lua/fknb/ui/output.lua` - Output Formatting

`output.lua` is dedicated to formatting the execution output received from the kernel into a visually appealing virtual text block. Its primary function is:

*   **`M.create_output_text(output_data)`:** Takes `output_data` (which includes content, execution count, and status) and generates a table of strings representing the formatted output. This includes:
    *   A top separator line.
    *   The actual output content lines.
    *   A footer line indicating the execution count and status (e.g., `─ Out[5] ─ ERROR ─`).

## UI Update Flow

1.  An event occurs (e.g., buffer change, kernel status update, spinner tick).
2.  `cell_ui.attach_autocmd()` triggers the `cell_ui.draw()` function.
3.  `cell_ui.draw()` parses the buffer, compares current and previous cell states, and identifies changes.
4.  For each changed cell, `cell_ui.draw()` calls `renderer.render_cell()`.
5.  `renderer.render_cell()` clears old extmarks for that cell and places new virtual lines for the cell header and, if present, the formatted output (generated by `output_ui.create_output_text()`).

This modular approach ensures efficient and responsive UI updates, only redrawing what's necessary.
